-module(icmp_data_scheme_seq_num_bits_send).

-export([init/1]).
-export([prepare_data/1]).
-export([log_echo_packet/2]).
-export([is_complete/1]).

-define(DEFAULT_PAYLOAD, "abc").

-include("icmp_data.hrl").

%%% Include for logging purposes
-include_lib("pkt/include/pkt.hrl").

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.

%%% TODO: use binary for data, and for incoming?
-record(mod_state_seq_num_bits_send, {
  id,
  current,
  rest,
  bit_num = 0,
  byte_num = 0,
  seq_num_base_for_bit = 0,
  seq_num_start_for_byte = 0
}).

%%% For each byte of the message, each bit is used to determine the id to use in a packet.
%%% Each byte has a starting id that will be used, and a base id for a given bit.
%%% For each bit, if it's 0, the base id is used. Else, the base id plus 1 is used.
%%% If there are bits left in the byte, the base id is then incremented by 2.
%%% Else, the base id and the starting id are set to the previous starting id plus
%%% ?SEQ_NUM_INC_PER_BYTE, and the next byte is processed.

init([H | T]) ->
  #mod_state_seq_num_bits_send{
    id = random:uniform(1 bsl 16) - 1,
    current = H,
    rest = T
  }.

prepare_data(ModState) ->
  #mod_state_seq_num_bits_send{
    id = Id,
    current = Current,
    seq_num_base_for_bit = SeqNumBaseForBit} = ModState,

  %% SeqNumBaseForBit is either SeqNumBaseForBit or SeqNumBaseForBit + 1,
  %%   depending on current bit being 0 or 1
  SeqNum = SeqNumBaseForBit + (Current band 1),

  %% TODO:
  %% Get last_id from State
  %% Delay = BaseDelay * (Id - LastId). Will be 0 for first one, which is good
  %% Pass Id to next_state to set last_id
  %% Include Delay in return tuple

  ModState2 = next_state(ModState),

  %{Id, ?DEFAULT_PAYLOAD, State2}.
  #send_prep{
    id      = Id,
    seq_num = SeqNum,
    payload = ?DEFAULT_PAYLOAD,
    state   = ModState2}.

%%% More bits left in Current
next_state(
    #mod_state_seq_num_bits_send{
      bit_num = BitNum} = ModState) when BitNum < 7 ->
  create_next_state(same_byte, ModState);

%%% Need to advance to next byte
next_state(
    #mod_state_seq_num_bits_send{
      rest = Rest,
      bit_num = BitNum} = ModState) when BitNum =:= 7 andalso Rest /= [] ->
  create_next_state(next_byte, ModState);

%%% Data is complete
next_state(
    #mod_state_seq_num_bits_send{
      rest = Rest,
      bit_num = BitNum} = ModState) when BitNum =:= 7 andalso Rest == [] ->
  create_next_state(complete, ModState).

%%%
create_next_state(
    same_byte,
    #mod_state_seq_num_bits_send{
      current = Current,
      bit_num = BitNum,
      seq_num_base_for_bit = SeqNumBaseForBit} = ModState) ->
  %% Advance to next bit and id base
  ModState#mod_state_seq_num_bits_send{
    current = Current bsr 1,
    bit_num = BitNum + 1,
    seq_num_base_for_bit = SeqNumBaseForBit + 2};

create_next_state(
    next_byte,
    #mod_state_seq_num_bits_send{
      rest = [H | T],
      byte_num = ByteNum,
      seq_num_start_for_byte = SeqNumStartForByte} = ModState) ->
  %% Advance to next base id for the next byte
  NextSeqNum = SeqNumStartForByte + ?SEQ_NUM_INC_PER_BYTE,

  ModState#mod_state_seq_num_bits_send{
    current = H,
    rest = T,
    bit_num = 0,
    byte_num = ByteNum + 1,
    seq_num_base_for_bit = NextSeqNum,
    seq_num_start_for_byte = NextSeqNum};

create_next_state(
    complete,
    ModState) ->
  %% Unset current, which is_complete/1 will check
  ModState#mod_state_seq_num_bits_send{
    current = undefined
  }.

log_echo_packet(
    Icmp,
    #mod_state_seq_num_bits_send{
      bit_num = BitNum,
      byte_num = ByteNum}) ->
  [IcmpHdr, Payload] = pkt:decapsulate(icmp, Icmp),
  %Id = IcmpHdr#icmp.id,
  SeqNum = IcmpHdr#icmp.sequence,
  lager:info("Byte ~p, bit ~p. Packet seqnum: ~p. Payload: ~p",
    [ByteNum, BitNum, SeqNum, Payload]),
  ok.

is_complete(#mod_state_seq_num_bits_send{current = undefined}) ->
  true;
is_complete(ModState) when is_record(ModState, mod_state_seq_num_bits_send) ->
  false.




%%%


-ifdef(TEST).

%%% 0 1 / 2 3 / 4 5 / 6 7 / 8 9
prepare_data_test() ->
  io:format("prepare_data_test~n"),
  %% $a == 97 == 2#01100001
  %% $b == 98 == 2#01100010
  State = icmp_data_scheme_seq_num_bits_send:init("ab"),

  ExpectedSeqNums =
    [1, 2, 4, 6, 8, 11, 13, 14] ++
    [16, 19, 20, 22, 24, 27, 29, 30],

  test_data(State, ExpectedSeqNums).

test_data(_State, []) ->
  ok;
test_data(State, [ExpectedSeqNum | T]) ->
  #send_prep{seq_num = SeqNum, state = State1} = icmp_data_scheme_seq_num_bits_send:prepare_data(State),
  ?assertEqual(ExpectedSeqNum, SeqNum),

  ExpectedIsComplete = T =:= [],
  ?assertEqual(ExpectedIsComplete, icmp_data_scheme_seq_num_bits_send:is_complete(State1)),

  test_data(State1, T).


-endif.

