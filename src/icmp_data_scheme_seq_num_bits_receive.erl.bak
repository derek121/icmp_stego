-module(icmp_data_scheme_seq_num_bits_receive).

-export([process_packet/2]).

-define(DEFAULT_PAYLOAD, "abc").

-include("icmp_data.hrl").
-include("icmp_data_scheme_seq_num_bits_receive.hrl").

-include_lib("pkt/include/pkt.hrl").

-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.


process_packet(_State, Ip) ->
  [_Ipv4Hdr, IcmpHdr, _Payload] = pkt:decapsulate(ipv4, Ip),
  SeqNum = IcmpHdr#icmp.sequence,
  Bit = extract_bit(SeqNum),
  handle_data(Bit).

extract_bit(SeqNum) ->
  Rem = (SeqNum rem ?SEQ_NUM_INC_PER_BYTE),
  IsFirst = (Rem =:= 0) or (Rem =:= 1),

  Val = SeqNum rem 2,
  #bit{val = Val, is_first = IsFirst}.

handle_data(Bit) ->
  icmp_data_scheme_seq_num_bits_receive_fsm:bit(Bit).



%%%



-ifdef(TEST).

extract_bit_test() ->
  Expected = [
    {0, #bit{is_first = true, val = 0}},
    {1, #bit{is_first = true, val = 1}},
    {2, #bit{is_first = false, val = 0}},
    {3, #bit{is_first = false, val = 1}},
    {4, #bit{is_first = false, val = 0}},
    {5, #bit{is_first = false, val = 1}},
    {6, #bit{is_first = false, val = 0}},
    {7, #bit{is_first = false, val = 1}},
    {8, #bit{is_first = false, val = 0}},
    {9, #bit{is_first = false, val = 1}},
    {10, #bit{is_first = false, val = 0}},
    {11, #bit{is_first = false, val = 1}},
    {12, #bit{is_first = false, val = 0}},
    {13, #bit{is_first = false, val = 1}},
    {14, #bit{is_first = false, val = 0}},
    {15, #bit{is_first = false, val = 1}},
    {16, #bit{is_first = true, val = 0}},
    {17, #bit{is_first = true, val = 1}},
    {18, #bit{is_first = false, val = 0}},
    {19, #bit{is_first = false, val = 1}},
    {20, #bit{is_first = false, val = 0}},
    {21, #bit{is_first = false, val = 1}}
  ],
  Fun = fun({Val, ExpectedRec}) ->
    ?assertEqual(ExpectedRec, extract_bit(Val))
  end,
  lists:map(Fun, Expected).

handle_data_ok_test() ->
  %% $a == 97 == 2#01100001
  %% $b == 98 == 2#01100010
  %% [1, 2, 4, 6, 8, 11, 13, 14] ++
  %% [20, 23, 24, 26, 28, 31, 33, 34],

  %% TODO: use eunit fixtures to start and stop the fsm for each test here?
  icmp_data_scheme_seq_num_bits_receive_fsm:start(),

  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(1))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(2))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(4))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(6))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(8))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(11))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(13))),
  ?assertEqual({complete, no_state, "a"}, handle_data(extract_bit(14))),

  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(16))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(19))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(20))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(22))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(24))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(27))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(29))),
  ?assertEqual({complete, no_state, "b"}, handle_data(extract_bit(30))),
  ok.

handle_data_exp_first_rec_non_test() ->
  %% $a == 97 == 2#01100001
  %% $b == 98 == 2#01100010
  %% [1, 2, 4, 6, 8, 11, 13, 14] ++
  %% [20, 23, 24, 26, 28, 31, 33, 34],

  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(1))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(2))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(4))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(6))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(8))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(11))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(13))),
  ?assertEqual({complete, no_state, "a"}, handle_data(extract_bit(14))),

  %% Now send a non-first
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(22))),

  %% Now go ahead with the next byte
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(16))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(19))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(20))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(22))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(24))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(27))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(29))),
  ?assertEqual({complete, no_state, "b"}, handle_data(extract_bit(30))),
  ok.

handle_data_exp_non_rec_first_test() ->
  %% $a == 97 == 2#01100001
  %% $b == 98 == 2#01100010
  %% [1, 2, 4, 6, 8, 11, 13, 14] ++
  %% [20, 23, 24, 26, 28, 31, 33, 34],

  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(1))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(2))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(4))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(6))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(8))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(11))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(13))),
  ?assertEqual({complete, no_state, "a"}, handle_data(extract_bit(14))),

  %% Go ahead with the next byte
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(16))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(19))),

  %% Now send a first bit, from the first sent above
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(33))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(34))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(36))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(38))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(40))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(43))),
  ?assertEqual({incomplete, no_state}, handle_data(extract_bit(45))),
  ?assertEqual({complete, no_state, "a"}, handle_data(extract_bit(46))),
  ok.


-endif.

